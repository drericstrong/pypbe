\hypertarget{classpypbe_1_1_p_b_e}{}\section{pypbe.\+P\+BE Class Reference}
\label{classpypbe_1_1_p_b_e}\index{pypbe.\+P\+BE@{pypbe.\+P\+BE}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classpypbe_1_1_p_b_e_ad36bf08bcbbbc904fb3ea360c18f694c}{\+\_\+\+\_\+init\+\_\+\+\_\+} (self, num\+\_\+dice, dice\+\_\+type, add\+\_\+val=0, num\+\_\+ability=6, num\+\_\+arrays=1, reroll=0, best\+\_\+dice=None, best\+\_\+ability=6, pbe\+\_\+map=\textquotesingle{}pf\textquotesingle{}, custom\+\_\+pbe\+\_\+map=None)
\item 
def \hyperlink{classpypbe_1_1_p_b_e_aff58246daa59e87f0261afc04a43f98e}{roll\+\_\+mc} (self, num\+\_\+hist=10 $\ast$$\ast$6)
\item 
def \hyperlink{classpypbe_1_1_p_b_e_a84bc2f7406dfee08c190e47d0c719554}{plot\+\_\+histogram} (self, title\+\_\+prefix=\char`\"{}\char`\"{}, title\+\_\+override=\char`\"{}\char`\"{}, figsize=(10, 8))
\item 
def \hyperlink{classpypbe_1_1_p_b_e_a8b3a78c46718bf12b2cb9e548d81528d}{get\+\_\+results} (self, title\+\_\+prefix=\char`\"{}\char`\"{}, title\+\_\+override=\char`\"{}\char`\"{}, round\+\_\+digits=2)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_a7624d1ac3da3cb3fcf89da5669cb7660}\label{classpypbe_1_1_p_b_e_a7624d1ac3da3cb3fcf89da5669cb7660}} 
{\bfseries num\+\_\+dice}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_a5007e074da7c722777f41eea45e26ff2}\label{classpypbe_1_1_p_b_e_a5007e074da7c722777f41eea45e26ff2}} 
{\bfseries dice\+\_\+type}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_a9f15770c8d7f30f5c5bc9080e1bdfe4f}\label{classpypbe_1_1_p_b_e_a9f15770c8d7f30f5c5bc9080e1bdfe4f}} 
{\bfseries add\+\_\+val}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_aed6e08f809eb22fb310b5d4ee68436cd}\label{classpypbe_1_1_p_b_e_aed6e08f809eb22fb310b5d4ee68436cd}} 
{\bfseries num\+\_\+ability}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_ad027d3e7ccf30e3fdf000cac4060cd41}\label{classpypbe_1_1_p_b_e_ad027d3e7ccf30e3fdf000cac4060cd41}} 
{\bfseries num\+\_\+arrays}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_ad9b8e799ffc4553d01d23d5444b7078d}\label{classpypbe_1_1_p_b_e_ad9b8e799ffc4553d01d23d5444b7078d}} 
{\bfseries reroll}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_aad217eb181f767c2872cea6714c89fea}\label{classpypbe_1_1_p_b_e_aad217eb181f767c2872cea6714c89fea}} 
{\bfseries best\+\_\+ability}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_a1a9b251922693fde671144303d8cf55e}\label{classpypbe_1_1_p_b_e_a1a9b251922693fde671144303d8cf55e}} 
{\bfseries pbe\+\_\+map}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_a2d050fa6237ab33c294c780997c1f8a8}\label{classpypbe_1_1_p_b_e_a2d050fa6237ab33c294c780997c1f8a8}} 
{\bfseries best\+\_\+dice}
\item 
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_a3b42329623dd1ca342fb30609477c0bf}\label{classpypbe_1_1_p_b_e_a3b42329623dd1ca342fb30609477c0bf}} 
{\bfseries pbe\+\_\+res}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}pypbe.PBE
Point Buy Equivalent
~~~~~~~~~~~~~~~~~~~~
Initializes a Monte Carlo simulation to determine the equivalent
Point Buy of an ability score rolling method.
\end{DoxyVerb}
 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_ad36bf08bcbbbc904fb3ea360c18f694c}\label{classpypbe_1_1_p_b_e_ad36bf08bcbbbc904fb3ea360c18f694c}} 
\index{pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def pypbe.\+P\+B\+E.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{num\+\_\+dice,  }\item[{}]{dice\+\_\+type,  }\item[{}]{add\+\_\+val = {\ttfamily 0},  }\item[{}]{num\+\_\+ability = {\ttfamily 6},  }\item[{}]{num\+\_\+arrays = {\ttfamily 1},  }\item[{}]{reroll = {\ttfamily 0},  }\item[{}]{best\+\_\+dice = {\ttfamily None},  }\item[{}]{best\+\_\+ability = {\ttfamily 6},  }\item[{}]{pbe\+\_\+map = {\ttfamily \textquotesingle{}pf\textquotesingle{}},  }\item[{}]{custom\+\_\+pbe\+\_\+map = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}pypbe.PBE
Point Buy Equivalent
~~~~~~~~~~~~~~~~~~~~
Initializes a Monte Carlo simulation to determine the equivalent
Point Buy of an ability score rolling method.

:param num_dice: num_dice- The number of dice to roll (i.e. this is
    the "3" in "3d6")
:param dice_type: The type of dice to roll (i.e. six-sided,
    eight-sided, etc. This is the "6" in "3d6")
:param add_val: The value to add to the dice roll. (i.e.
    this is the "8" in "1d10+8")
:param num_ability: The number of ability scores to generate (e.g. 6)
:param num_arrays: The number of ability scores arrays that can be
    chosen from. For instance, 2 arrays might allow the player to
    choose between [12,10,6,11,15,17] and [6,9,12,18,15,10]
:param reroll: Allow dice re-rolling, cumulatively. "0" is no re-rolls,
    "1" is re-rolling 1s, and "2" is re-rolling 1s and 2s, and so on.
:param best_dice: If you want to roll more dice than you need
    and then take the best N results. E.g. "Roll 4d6 and drop the
    lowest roll" would require a "3" here.
:param best_ability: If you want to roll more abilities than you need
    and then take the best N results. E.g. "Roll 3d6 seven times,
    and take the best six times" would require a "6" here.
:param pbe_map: This determines how much each ability score will
    "cost" in the Point Buy system. You supply a string here, and
    the default is Pathfinder. You can (currently) select Pathfinder:
    'pf', D&D 3e: '3e', D&D 4e: '4e', or D&D 5e: '5e'
:param custom_pbe_map: If you want, you can supply a custom Point Buy
\end{DoxyVerb}
 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classpypbe_1_1_p_b_e_a8b3a78c46718bf12b2cb9e548d81528d}\label{classpypbe_1_1_p_b_e_a8b3a78c46718bf12b2cb9e548d81528d}} 
\index{pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}!get\+\_\+results@{get\+\_\+results}}
\index{get\+\_\+results@{get\+\_\+results}!pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}}
\subsubsection{\texorpdfstring{get\+\_\+results()}{get\_results()}}
{\footnotesize\ttfamily def pypbe.\+P\+B\+E.\+get\+\_\+results (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{title\+\_\+prefix = {\ttfamily \char`\"{}\char`\"{}},  }\item[{}]{title\+\_\+override = {\ttfamily \char`\"{}\char`\"{}},  }\item[{}]{round\+\_\+digits = {\ttfamily 2} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Constructs a summary of the results as an array, which might be
useful for writing the results of multiple algorithms to a table.
NOTE- This method must be called AFTER "roll_mc".

:param title_prefix: If desired, prefix the title (such as "Alg 1")
:param title_override: Override the title string entirely
:param round_digits: the number of digits to round to
:return: A tuple of the raw array results and PBE results, as:
 [Description, Typical Array, Mean, Std, 5%, 95%]
\end{DoxyVerb}
 \mbox{\Hypertarget{classpypbe_1_1_p_b_e_a84bc2f7406dfee08c190e47d0c719554}\label{classpypbe_1_1_p_b_e_a84bc2f7406dfee08c190e47d0c719554}} 
\index{pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}!plot\+\_\+histogram@{plot\+\_\+histogram}}
\index{plot\+\_\+histogram@{plot\+\_\+histogram}!pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}}
\subsubsection{\texorpdfstring{plot\+\_\+histogram()}{plot\_histogram()}}
{\footnotesize\ttfamily def pypbe.\+P\+B\+E.\+plot\+\_\+histogram (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{title\+\_\+prefix = {\ttfamily \char`\"{}\char`\"{}},  }\item[{}]{title\+\_\+override = {\ttfamily \char`\"{}\char`\"{}},  }\item[{}]{figsize = {\ttfamily (10,~8)} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Plots a histogram of the results after the Monte Carlo simulation is
run. NOTE- This method must be called AFTER "roll_mc".

This method returns self, so you can stack the "get_results" method,
like pbe1.roll_mc().plot_histogram().get_results()

:param title_prefix: If desired, prefix the title (such as "Alg 1")
:param title_override: Override the title string entirely
:param figsize: The size of the histogram plot
\end{DoxyVerb}
 \mbox{\Hypertarget{classpypbe_1_1_p_b_e_aff58246daa59e87f0261afc04a43f98e}\label{classpypbe_1_1_p_b_e_aff58246daa59e87f0261afc04a43f98e}} 
\index{pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}!roll\+\_\+mc@{roll\+\_\+mc}}
\index{roll\+\_\+mc@{roll\+\_\+mc}!pypbe\+::\+P\+BE@{pypbe\+::\+P\+BE}}
\subsubsection{\texorpdfstring{roll\+\_\+mc()}{roll\_mc()}}
{\footnotesize\ttfamily def pypbe.\+P\+B\+E.\+roll\+\_\+mc (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{num\+\_\+hist = {\ttfamily 10$\ast$$\ast$6} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Runs the initialized Monte Carlo simulation to determine the equivalent
Point Buy of an ability score rolling method. NOTE- This method must
be called BEFORE "plot_histogram".

This method returns self, so you can stack the "plot_histogram" and
"get_results" methods, like pbe1.roll_mc().plot_histogram()

:param num_hist: Number of Monte Carlo histories to run. Suggest 10**6
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\+\_\+\+\_\+init\+\_\+\+\_\+.\+py\end{DoxyCompactItemize}
